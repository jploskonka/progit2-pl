[[_rebasing]]
=== Zmiana bazy

(((rebasing)))
W Git istnieją dwa podstawowe sposoby integrowania zmian z jednej gałęzi do drugiej: scalanie (polecenie `merge`) oraz zmiana bazy (polecenie `rebase`). W tym rozdziale dowiesz się, czym jest zmiana bazy, jak ją przeprowadzić, dlaczego jest to świetne narzędzie i w jakich przypadkach lepiej się powstrzymać od jego wykorzystania.

==== Typowa zmiana bazy

Jeśli cofniesz się do poprzedniego przykładu z sekcji Scalanie (patrz Rysunek 3-27), zobaczysz, że rozszczepiłeś swoją pracę i wykonywałeś zmiany w dwóch różnych gałęziach.

.Początkowa historia po rozszczepieniu.
image::images/basic-rebase-1.png[Simple divergent history.]

Najprostszym sposobem, aby zintegrować gałęzie - jak już napisaliśmy - jest polecenie `merge`. Przeprowadza ono trójstronne scalanie pomiędzy dwoma ostatnimi migawkami gałęzi (C3 i C4) oraz ich ostatnim wspólnym przodkiem (C2), tworząc nową migawkę (oraz rewizję), tak jak widać to na rysunku 3-28.

.Scalanie gałęzi integrujące rozszczepioną historię zmian.
image::images/basic-rebase-2.png[Merging to integrate diverged work history.]

Jednakże istnieje inny sposób: możesz stworzyć łatkę ze zmianami wprowadzonymi w C3 i zaaplikować ją na rewizję C4. W Gicie nazywa się to zmianą bazy (ang. rebase). Dzięki poleceniu `rebase` możesz wziąć wszystkie zmiany, które zostały zatwierdzone w jednej gałęzi i zaaplikować je w innej.

W tym wypadku, mógłbyś uruchomić następujące polecenie:

[source,console]
----
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
----

Polecenie to działa przesuwając się do ostatniego wspólnego przodka obu gałęzi (tej w której się znajdujesz oraz tej *do* której robisz zmianę bazy), pobierając różnice opisujące kolejne zmiany (ang. diffs) wprowadzane przez kolejne rewizje w gałęzi w której się znajdujesz, zapisując je w tymczasowych plikach, następnie resetuje bieżącą gałąź do tej samej rewizji *do* której wykonujesz operację zmiany bazy, po czym aplikuje po kolei zapisane zmiany. Ilustruje to rysunek 3-29.


.Zmiana bazy dla zmian wprowadzonych w `C3` do `C4`
image::images/basic-rebase-3.png[Rebasing the change introduced in `C4` onto `C3`.]

W tym momencie możesz wrócić do gałęzi `master` i scalić zmiany wykonując proste przesunięcie wskaźnika (co przesunie wskaźnik master na koniec).

[source,console]
----
$ git checkout master
$ git merge experiment
----

.Przesunięcie gałęzi master po operacji zmiany bazy.
image::images/basic-rebase-4.png[Fast-forwarding the master branch.]

Teraz migawka wskazywana przez C3' jest dokładnie taka sama jak ta, na którą wskazuje C5 w przykładzie ze scalaniem. Nie ma różnicy w produkcie końcowym integracji. Zmiana bazy tworzy jednak czystszą historię. Jeśli przejrzysz historię gałęzi po operacji `rebase`, wygląda ona na liniową: wygląda jakby cała praca była wykonywana stopniowo, nawet jeśli oryginalnie odbywała się równolegle.

Ostateczny efekt scalania i przerzucania jest taki sam, ale przerzucanie pozwala zachować czystszą historię zmian.
Jeśli popatrzysz na log przerzuconej gałęzi wygląda on jak prosta, liniowa historia: tak jakby cała praca była
wykonywana po kolei, nawet jeśli oryginalnie miała miejsce równolegle.

Warto korzystać z tej funkcji, by mieć pewność, że rewizje zaaplikują się w bezproblemowy sposób do zdalnej gałęzi - być może w projekcie w którym próbujesz się udzielać, a którym nie zarządzasz. W takim wypadku będziesz wykonywał swoją pracę we własnej gałęzi, a następnie zmieniał jej bazę na `origin/master`, jak tylko będziesz gotowy do przesłania własnych poprawek do głównego projektu. W ten sposób osoba utrzymująca projekt nie będzie musiała dodatkowo wykonywać integracji - jedynie prostolinijne scalenie lub czyste zastosowanie zmian.

Zauważ, że migawka wskazywana przez wynikową rewizję bez względu na to, czy jest to ostatnia rewizja po zmianie bazy lub ostatnia rewizja scalająca po operacji scalania, to taka sama migawka - różnica istnieje jedynie w historii. Zmiana bazy nanosi zmiany z jednej linii pracy do innej w kolejności, w jakiej były one wprowadzane, w odróżnieniu od scalania, które bierze dwie końcówki i integruje je ze sobą.

==== Ciekawsze operacje zmiany bazy

Poleceniem `rebase` możesz także zastosować zmiany na innej gałęzi niż ta, której zmieniasz bazę. Dla przykładu - weź historię taką jak <<rbdiag_e>>. Utworzyłeś gałąź tematyczną (`server`), żeby dodać nowe funkcje do kodu serwerowego, po czym utworzyłeś rewizję. Następnie utworzyłeś gałąź, żeby wykonać zmiany w kliencie (`client`) i kilkukrotnie zatwierdziłeś zmiany. W końcu wróciłeś do gałęzi `server` i wykonałeś kilka kolejnych rewizji.

[[rbdiag_e]]
.Historia z gałęzią tematyczną utworzoną na podstawie innej gałęzi tematycznej.
image::images/interesting-rebase-1.png[A history with a topic branch off another topic branch.]

Załóżmy, że zdecydowałeś się scalić zmiany w kliencie do kodu głównego, ale chcesz się jeszcze wstrzymać ze zmianami po stronie serwera, dopóki nie zostaną one dokładniej przetestowane. Możesz wziąć zmiany w kodzie klienta, których nie ma w kodzie serwera (C8 i C9) i zastosować je na gałęzi głównej używając opcji `--onto` polecenia `git rebase`:

[source,console]
----
$ git rebase --onto master server client
----

Oznacza to mniej więcej "Przełącz się do gałęzi klienta, określ zmiany wprowadzone od wspólnego przodka gałęzi `client` i `server`, a następnie nanieś te zmiany na gałąź główną `master`. Jest to nieco skomplikowane, ale wynik (pokazany na <<rbdiag_g>>) całkiem niezły.

.Zmiana bazy gałęzi tematycznej odbitej z innej gałęzi tematycznej.
image::images/interesting-rebase-2.png[Rebasing a topic branch off another topic branch.]

Teraz możesz zwyczajnie przesunąć wskaźnik gałęzi głównej do przodu (rysunek 3-33):

[source,console]
----
$ git checkout master
$ git merge client
----

[[rbdiag_g]]
.Przesunięcie do przodu gałęzi master w celu uwzględnienia zmian z gałęzi klienta.
image::images/interesting-rebase-3.png[Fast-forwarding your master branch to include the client branch changes.]

Powiedzmy, że zdecydujesz się pobrać i scalić zmiany z gałęzi `server`. Możesz zmienić bazę gałęzi `server` na wskazywaną przez `master` bez konieczności przełączania się do gałęzi `server` używając `git rebase [gałąź bazowa] [gałąź tematyczna]` - w ten sposób zmiany z gałęzi `server` zostaną zaaplikowane do gałęzi bazowej `master`:

[source,console]
----
$ git rebase master server
----

Polecenie odtwarza zmiany z gałęzi `server` na gałęzi `master` tak, jak pokazuje to <<rbdiag_h>>.

[[rbdiag_h]]
.Zmiana bazy gałęzi `serwer` na koniec gałęzi głównej.
image::images/interesting-rebase-4.png[Rebasing your server branch on top of your master branch.]

Następnie możesz przesunąć gałąź bazową (`master`):

[source,console]
----
$ git checkout master
$ git merge server
----

Możesz teraz usunąć gałęzie `client` i `server`, ponieważ cała praca jest już zintegrowana i więcej ich nie potrzebujesz pozostawiając historię w stanie takim, jaki obrazuje rysunek <<rbdiag_i>>:

[source,console]
----
$ git branch -d client
$ git branch -d server
----

[[rbdiag_i]]
.Ostateczna historia rewizji
image::images/interesting-rebase-5.png[Final commit history.]

[[_rebase_peril]]
==== Zagrożenia oepracji zmiany bazy

(((rebasing, perils of)))
Błogosławieństwo, jakie daje możliwość zmiany bazy, ma swoją mroczną stronę. Można ją podsumować jednym zdaniem:

**Nie zmieniaj bazy rewizji, które wypchnąłeś już do publicznego repozytorium.**

Jeśli będziesz się stosował do tej reguły, wszystko będzie dobrze. W przeciwnym razie ludzie cię znienawidzą, a rodzina i przyjaciele zaczną omijać szerokim łukiem.

Stosując operację zmiany bazy porzucasz istniejące rewizje i tworzysz nowe, które są podobne, ale inne. Wypychasz gdzieś swoje zmiany, inni je pobierają, scalają i pracują na nich, a następnie nadpisujesz te zmiany poleceniem `git rebase` i wypychasz ponownie na serwer. Twoi współpracownicy będą musieli scalić swoją pracę raz jeszcze i zrobi się bałagan, kiedy spróbujesz pobrać i scalić ich zmiany z powrotem z twoimi.

Spójrzmy na przykład obrazujący, jak operacja zmiany bazy może spowodować problemy. Załóżmy, że sklonujesz repozytorium z centralnego serwera, a następnie wykonasz bazując na tym nowe zmiany. Twoja historia rewizji wygląda tak jak na rysunku:

.Skolowane repozytorium i dokonane zmiany
image::images/perils-of-rebasing-1.png["Clone a repository, and base some work on it."]


Teraz ktoś inny wykonuje inną pracę, która obejmuje scalenie, i wypycha ją na centralny serwer. Pobierasz zmiany, scalasz nową, zdalną gałąź z własną pracą, w wyniku czego historia wygląda mniej więcej tak, jak na rysunku 3-37.

.Pobranie kolejnych rewizji i scalenie ich z własnymi zmianami.
image::images/perils-of-rebasing-2.png["Fetch more commits, and merge them into your work."]

Następnie osoba, która wypchnęła scalone zmiany, rozmyśliła się i zdecydowała zamiast scalenia zmienić bazę swoich zmian; wykonuje `git push --force`, żeby zastąpić historię na serwerze. Następnie ty pobierasz dane z serwera ściągając nowe rewizje.


[[_pre_merge_rebase_work]]
.Ktoś wypycha rewizje po operacji zmiany bazy porzucając rewizje, na których ty oparłeś swoje zmiany.
image::images/perils-of-rebasing-3.png["Someone pushes rebased commits, abandoning commits you've based your work on."]

W tym momencie musisz raz jeszcze scalać tę pracę mimo tego, że już to wcześniej raz zrobiłeś. Operacja zmiany bazy zmienia sumy kontrolne SHA-1 tych rewizji, więc dla Gita wyglądają one jak zupełnie nowe, choć w rzeczywistości masz już zmiany wprowadzone w C4 w swojej historii (rysunek 3-39).

[[_merge_rebase_work]]
.Scalasz tą samą pracę raz jeszcze tworząc nową rewizję scalającą.
image::images/perils-of-rebasing-4.png[You merge in the same work again into a new merge commit.]

Musisz scalić swoją pracę w pewnym momencie po to, żeby dotrzymywać kroku innym programistom. Kiedy już to zrobisz, Twoja historia zmian będzie zawierać zarówno rewizje C4 jak i C4', które mają różne sumy SHA-1, ale zawierają te same zmiany i mają ten sam komentarz. Jeśli uruchomisz `git log` dla takiej historii, zobaczysz dwie rewizje mające tego samego autora, datę oraz komentarz, co będzie mylące. Co więcej, jeśli wypchniesz tę historię z powrotem na serwer, raz jeszcze wprowadzisz wszystkie rewizje powstałe w wyniku operacji zmiany bazy na serwer centralny, co może dalej mylić i denerwować ludzi.

Jeśli traktujesz zmianę bazy jako sposób na porządkowanie historii i sposób pracy z rewizjami przed wypchnięciem ich na serwer oraz jeśli zmieniasz bazę tylko tym rewizjom, które nigdy wcześniej nie były dostępne publicznie, wówczas wszystko będzie w porządku. Jeśli zaczniesz zmieniać bazę rewizjom, które były już publicznie dostępne, a ludzie mogą na nich bazować swoje zmiany, wówczas możesz wpaść w naprawdę frustrujące tarapaty.


[WIP: further down...]
[[_rebase_rebase]]
==== Przerzucaj kiedy przerzucasz

Jeśli już znajdziesz się w sytuacji jak powyższa, Git oferuję odrobinę więcej magii, która może Ci pomóc. Jeśli ktoś z
Twojego zespołu wymusi wypchanie zmian, która nadpisują pracę, na której się opierasz wyzwanie polega na ustalniu co
jest Twoje a co zostało nadpisane.

Okazuje się, że oprócz sumy kontrolnej SHA-1 rewizji, Git oblicza również sumę kontrolną bazując tylko na wprowadzanych
zmianach. Nazywa się to ``patch-id''.

Jeśli pobierzesz zmiany, które zostały nadpisane i przerzucisz je na nowe rewizje Twojego współpracownika, Git często
potrafi ustalić co jest unikalnie Twoje i zaaplikować to spowrotem na nowej gałęzi.

Popatrzmy na poprzedni przykład, jeśli zamiast wykonywać scalanie kiedy jesteś w sytuacji <<_pre_merge_rebase_work>>
wykonasz `git rebase teamone/master` Git wykona następujące rzeczy:

* Ustali jaka praca jest unikalna dla Twojej gałęzi (C2, C3, C4, C6, C7)
* Ustali, które rewizje nie są rewizjami-scalającymi (C2, C3, C4)
* Ustali, które zmiany nie zostały wprowadzone w docelowej gałęzi (tylko C2 i C3, ponieważ C4 zawiera te same zmiany co C4')
* Powtórzy te rewizje na gałęzi `teamone/master`

Zamiast rezultatu jak <<_merge_rebase_work>>, skończysz z hitorią bardziej jak <<_rebase_rebase_work>>.

[[_rebase_rebase_work]]
.Rebase on top of force-pushed rebase work.
image::images/perils-of-rebasing-5.png[Rebase on top of force-pushed rebase work.]

Zadziała to tylko wtedy jeśli C4 i C4' wykonane przez Twojego współpracownika są prawie identyczne. W przeciwnym wypadku
przerzuczania nie będzie w stanie ustalić, że zmiany są zduplikowane i utworzy jeszcze jedna rewizję podobną do C4
(której prawdopodobnie nie uda się czysto zaaplikować, bo zmiany już tak-jakby będą znajdować się w Twojej gałęzi).

Możesz to również uprościć używając `git pull --rebase` zamiast standardowego `git pull`. Lub możesz to zrobić manualnie
przy użyciu `git fetch`, a następnie `git rebase reamone/master` w tym przypadku.

Jeśli używasz `git pull` i chcesz ustawić przełącznik `--rebase` jako domyślny, możesz użyć opcji konfiguracji
`pull.rebase` poprzez komendę `git config --global pull.rebase true`.

Jeśli traktujesz przerzucanie jako sposób na utrzymanie porządku w historii zanim wypchasz swoje zmiany oraz jeśli
przerzucasz tylko rewizje, które nigdy nie były dostępne publicznie wtedy wszystko będzie w porządku.

Jeśli przerzucasz rewizje, które już zostały upublicznione i ludzie mogli bazować swoje zmiany na tych rewizjach, wtedy
możesz napotkać frustrujące problemy.

Jeśli Ty lub Twoj współpracownik uzna przerzucanie za konieczne w jakimś momencie upewnij się, że wszyscy wiedzą o
użyciu `git pull --rebase` aby zminimalizować problemy.

==== Przerzucania vs. scalanie

(((rebasing, vs. merging)))(((merging, vs. rebasing)))
Kiedy juz widziałeś przerzucanie i scalanie w akcji, możesz zastanawiać się, które z nich jest lepsze.
Zanim odpowiemy na to pytanie, zróbmy krok wstecz i pomówmy o tym czym właściwie jest historia.

Z jednej strony możesz na to patrzeć w ten sposób, że historia jest *zapisem co tak naprawdę się stało*. Jest dokumentem
historycznym, wartościowym samym w sobie i nie powinno się go modyfikować.
Z tego punktu, zmiany w histori są niemalże bluźnierstwem; _kłamiesz_ na temat tego co zaszło.
Co z tego, że gdzieś seria brzydkich i bałaganiarskich rewizji scalających?
To właśnie się stało i repozytorium powinno zachować to dla potomnych.

Z drugiej strony możesz na to patrzeć, tak że historia opowiada *jak Twój projekt został zrobiony.*
Nie opublikowałbys pierwszego szkicu książki, i instrukcja jak używać Twojego oprogramowania zasługuje na pieczołowite
edytowanie. To jest obóz ludzi, którzy uzywają narzędzi takich jak przerzucanie oraz `filter-branch` aby opowiedzieć
historię repozytorium tak dobrze jak to tylko możliwe dla przyszłych czytelników.

Teraz wracając do pytania czy przerzucanie czy scalanie jest lepsze: mam nadzieję, że widzisz już, że nie jest to takie
proste. Git jest potężnym narzędziem pozwalającym na zrobienie wielu rzeczy z i Twojej historii, ale każdy zespół i
każdy projekt są inne.
Kiedy już wiesz jak obie te rzeczy działają to do Ciebie należy decyzja, która z nich jest lepsza w Twojej specyficznej
sytuacji.

Ogólnie sposobem na dostanie tego co najlepsze z obu jest przerzucanie lokalnym zmian, którymi jeszcze nie podzieliłeś
się ze światem przed ich wypchaniem, aby zachować porządek w historii, ale nigdy nie przerzucaj zmian, które
już upubliczniłeś.
